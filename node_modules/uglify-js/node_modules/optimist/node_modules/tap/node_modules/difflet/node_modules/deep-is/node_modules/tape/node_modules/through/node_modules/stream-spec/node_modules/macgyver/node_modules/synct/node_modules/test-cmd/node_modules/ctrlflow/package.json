{
  "name": "ctrlflow",
  "description": "mission critical ctrl flow library",
  "version": "4.1.3",
  "homepage": "https://github.com/dominictarr/ctrlflow",
  "repository": {
    "type": "git",
    "url": "git://github.com/dominictarr/ctrlflow.git"
  },
  "author": {
    "name": "Dominic",
    "email": "dominic.tarr@gmail.com"
  },
  "main": "./ctrlflow.js",
  "dependencies": {
    "curry": "0.0.x",
    "d-utils": "~1.4"
  },
  "readme": "#ctrlflow#\n\nAsyncronous control flow is important in most node.js programs, \nand it seems that every one has written a library to prevent callbacks getting out of hand. \nmost notably, creationix's `step` SubStack's `seq`, isaacs's `slide`, and caolan`s async.\n\nThese modules all do somethings right, but still leave room for improvement.\n`ctrlflow` combines the best features of these modules with a simple & flexible API and a \nfocus on robust error handling.\n\n## var go = ctrl(ArrayOFSteps); go(args,...,callback).\n\n`ctrl` takes an array of steps, and combines them into one asyncronous function that will call \neach step in sequence, and callback when the last step finishes, or when a step errors.\n\neach step is wrapped in a try ... catch, and if a function throws, \nit will stop executing the steps and pass the error to the final callback.\n\n##basic example\n\n``` js\nvar go = \n  ctrl([\n    fs.readFile,\n    function (buffer, callback) {\n      callback(null, JSON.parse(buffer.toString()))\n    }\n  ])\n\ngo('/path/to/config.json', function (err, obj) {\n  if(err)\n    throw err //print to stderr and exit\n  console.log(obj)\n})\n```\n\nThis example illistrates several things. \nFirstly, `seq` returns an ayncronous function, `go`.\nThe args passed to `go` are passed to the first step, `fs.readFile`, \nand the results of `fs.readFile` (minus the err parameter) are passed to the second step, \nwhich parses the file, then callsback.\n\nIf the file does not exist, readFile will callback with an error. \nIf the file exists, but is not valid JSON, `JSON.parse` will throw syncronously. \n(this will be caught be `seq`, so beware that mulitple types of errors be passed to the callback.\n\n##parallel group example\n\nSometimes you want to several async steps in parallel, ctrlflow has a literal syntax for this too!\n\na simple usecase for this is to call stat on a file, and, just incase it is a symbolic link, \ncall lstat as well. (lstat will stat the link file, not the file it links to)\n\n``` js\nctrl([{\n  stat: fs.stat\n  lstat: fs.lstat\n}])\n(filename, function (err, stats) {\n  console.log(stats)\n})  \n\n```\n\n##all together\n\n``` js\n  var ctrl = require('ctrlflow')\n  var go = \n  ctrl.seq([\n    function () {\n      //call the next step\n      this.next()\n    },\n    [asyncFunction, 1, 4, 'hello'], // short for: function () {asyncFunction(1, 4, 'hello', this.next)}\n    { a: function () {this.next() } // a, b, c are executed in parallel\n    , b: [\n        [asyncFunction, 1]\n      , [asyncFunction, 2]\n      , [asyncFunction, 3] \n      ]\n    , c: { //c itself has two parallel steps!\n        x: function () {this.next() } \n      , y: [[asyncFunction]]\n      }}\n  ])\n  //seq returned a function, call it, passing a callback:\n  \n  go(1, 2, 3, function (err) {\n    //passing in a callback that will be called when the entire tree/sequence is complete\n  })\n\n```\n\n## ERROR HANDLING\n\nif any step throws or callsback with an error, \nthe callback passed to `go` will be called with the error.\nno further steps will be called.\n\n\n``` js\n  var ctrl = require('ctrlflow')\n  var go = \n  ctrl.seq([\n    function () {\n      if(Math.random() < 0.5)\n        this.next(new Error('ERROR PASSED TO CALLBACK'))\n      else\n        throw new Error('ERROR THROWN')\n    },\n  ])\n  //seq returned a function, call it, passing a callback:\n  \n  go(function (err) {\n    //go will get called back with the error every time.\n  })\n\n```\n\n## grabbing the callback\n\nthe callback is always added as the last argument, and as `this.next`\nthe best way to get the callback is to pop it off the arguments \n\n``` js\n var callback = [].slice.call(arguments)\n```\n\n",
  "readmeFilename": "README.md",
  "_id": "ctrlflow@4.1.3",
  "dist": {
    "shasum": "d979635542d2a8d0b508ca9009dba39d22719c31"
  },
  "_from": "ctrlflow@~4.1",
  "_resolved": "https://registry.npmjs.org/ctrlflow/-/ctrlflow-4.1.3.tgz",
  "scripts": {}
}
